<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>index.esm.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="LoadRobot.html">LoadRobot</a><ul class='methods'><li data-type='method'><a href="LoadRobot.html#getEnvConfig">getEnvConfig</a></li><li data-type='method'><a href="LoadRobot.html#.createInstance">createInstance</a></li><li data-type='method'><a href="LoadRobot.html#.createLink">createLink</a></li><li data-type='method'><a href="LoadRobot.html#.createScript">createScript</a></li><li data-type='method'><a href="LoadRobot.html#.getInstance">getInstance</a></li><li data-type='method'><a href="LoadRobot.html#.load">load</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-sass-resources-loader.html">sass-resources-loader</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addDefinitionsEnvValue">addDefinitionsEnvValue</a></li><li><a href="global.html#addSplitChunksPlugin">addSplitChunksPlugin</a></li><li><a href="global.html#getType">getType</a></li><li><a href="global.html#getWebpackPlugin">getWebpackPlugin</a></li><li><a href="global.html#modifyOutputConfig">modifyOutputConfig</a></li><li><a href="global.html#override">override</a></li><li><a href="global.html#readAllDotenvFiles">readAllDotenvFiles</a></li><li><a href="global.html#readDotenvFiles">readDotenvFiles</a></li><li><a href="global.html#resolveApp">resolveApp</a></li><li><a href="global.html#writeConfigForDebug">writeConfigForDebug</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">index.esm.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import path from 'node:path';
import fs from 'node:fs';
import { getLoader, loaderByName, addAfterLoader } from '@craco/craco';

const appDirectory = fs.realpathSync(process.cwd());
/** load file */
const resolveApp = relativePath => path.resolve(appDirectory, relativePath);
/** look for webpack plugin that you expect */
const getWebpackPlugin = (plugins = [], pluginName, id = 0) => {
  if (id === 0) {
    return plugins.find(plugin => plugin.constructor.name === pluginName);
  }
  const sets = plugins.filter(plugin => plugin.constructor.name === pluginName);
  if (id > sets.length) throw new Error('Function getWebpackPlugin');
  return sets[id];
};
/** get target type */
const getType = target => {
  return Object.prototype.toString.call(target).slice(8, -1).toLocaleLowerCase();
};
/**
 *
 * @param haystack
 * @param needle inserted position
 * @param insertedString
 * @returns {string} concatenated string
 * @ignore
 */
const insertStringAfter = (haystack, needle, insertedString) => {
  if (!insertedString) return haystack;
  const needleString = String(needle);
  const index = haystack.indexOf(needleString);
  if (index === -1) {
    return haystack;
  }
  const endIndex = index + needleString.length;
  return haystack.slice(0, endIndex) + insertedString + haystack.slice(endIndex);
};
/**
 *
 * @param haystack
 * @param needle inserted position
 * @param insertedString
 * @returns {string} concatenated string
 * @ignore
 */
const insertStringBefore = (haystack, needle, insertedString) => {
  if (!insertedString) return haystack;
  const needleString = String(needle);
  const index = haystack.indexOf(needleString);
  if (index === -1) {
    return haystack;
  }
  return haystack.slice(0, index) + insertedString + haystack.slice(index);
};

// import fs from 'node:fs'
/**
 * For debugging,write config to webpack.config.json file
 */
const writeConfigForDebug = filename => config => {
  if (!filename) {
    throw new Error('Function: writeConfigForDebug must has a parameter');
  }
  const fs = require('node:fs');
  const path = require('node:path');
  fs.writeFileSync(path.join(process.cwd(), filename), JSON.stringify(config, (key, val) => {
    if (Object.prototype.toString.call(val) === '[object RegExp]') {
      return val.toString();
    }
    return val;
  }, 2));
  return config;
};
/**
 * modify `DefinePlugin` config
 * @param {Object} value Environment object
 * */
const addDefinitionsEnvValue = value => config => {
  const plugin = getWebpackPlugin(config.plugins, 'DefinePlugin');
  if (!plugin) throw new Error("DefinePlugin don't exist!");
  const processEnv = plugin.definitions['process.env'] || {};
  plugin.definitions['process.env'] = {
    ...processEnv,
    ...value
  };
  return config;
};
const addHtmlWebpackPlugin = (value, id) => config => {
  const plugin = getWebpackPlugin(config.plugins, 'HtmlWebpackPlugin', id);
  if (!plugin) throw new Error("HtmlWebpackPlugin don't exist!");
  Object.assign(plugin, value);
  console.log(plugin, 'htmlwebpackplugin');
  // const
  return config;
};
const addInterpolateHtmlPlugin = value => config => {
  const plugin = getWebpackPlugin(config.plugins, 'InterpolateHtmlPlugin');
  if (!plugin) throw new Error("InterpolateHtmlPlugin don't exist!");
  // const { replacements = {}, ...rest } = value
  Object.assign(plugin?.replacements, value);
  // Object.assign(plugin, rest)
  return config;
};
/** modify output config */
const modifyOutputConfig = (modify, removeSet = []) => config => {
  if (getType(modify) !== 'object') {
    throw new Error("Function: modifyOutputConfig's first parameter must be object!");
  }
  if (getType(removeSet) !== 'array') {
    throw new Error("Function: modifyOutputConfig's second parameter must be array!");
  }
  if (typeof config.output !== 'object') return config;
  Object.assign(config.output, modify);
  if (!config.output) return config;
  for (const key of removeSet) {
    delete config.output[key];
  }
  return config;
};
/** add split chunk plugin  */
const addSplitChunksPlugin = value => config => {
  const splitChunks = config.optimization?.splitChunks || {};
  Object.assign(splitChunks, value);
  config.optimization.splitChunks = splitChunks;
  return config;
};

class HtmlWebpackInjectHead {
  constructor(htmlWebpackPlugin, options) {
    this.htmlWebpackPlugin = htmlWebpackPlugin;
    this.options = {
      position: 'start',
      ...options
    };
  }
  apply(compiler) {
    compiler.hooks.compilation.tap('HtmlWebpackInjectHead', compilation => {
      this.htmlWebpackPlugin.getHooks(compilation).beforeEmit.tap('HtmlWebpackInjectHead', data => {
        if (this.options.position === 'end') {
          data.html = insertStringBefore(data.html, '&lt;/head>', this.options.content);
        } else {
          data.html = insertStringAfter(data.html, '&lt;head>', this.options.content);
        }
        return data;
      });
    });
  }
}

class HtmlWebpackMixinRobot {
  constructor(htmlWebpackPlugin, options) {
    this.htmlWebpackPlugin = htmlWebpackPlugin;
    this.options = {
      robot: '_BIU_LOAD_ROBOT',
      force: false,
      ...options
    };
  }
  static insertRobotFunc(html, tags, position, options) {
    if (!tags.length) return html;
    const formatTags = tags.map(tag => {
      const {
        tagName,
        attributes
      } = tag;
      return {
        tagName,
        attributes
      };
    });
    const str = `&lt;script>${options.robot}.loadOrigin(${JSON.stringify(formatTags)}, "${position}")&lt;/script>`;
    return insertStringBefore(html, `&lt;/${position}>`, str);
  }
  apply(compiler) {
    compiler.hooks.compilation.tap('HtmlWebpackMixinRobot', compilation => {
      this.htmlWebpackPlugin.getHooks(compilation).afterTemplateExecution.tap('HtmlWebpackMixinRobot', data => {
        // const fs = require("node:fs")
        // const path = require("node:path")
        // fs.writeFileSync(
        //   path.join(process.cwd(), "__HtmlWebpackMixinRobot"),
        //   JSON.stringify(
        //     data,
        //     (key, val) => {
        //       if (Object.prototype.toString.call(val) === "[object RegExp]") {
        //         return val.toString()
        //       }
        //       return val
        //     },
        //     2
        //   )
        // )
        // 动态创建base标签
        if (this.options.env &amp;&amp; this.options.robotUrl) {
          const str = `&lt;script src="${this.options.robotUrl}">&lt;/script>&lt;script>${this.options.robot}.createInstance(${this.options.env}, {key: "${this.options.robotInstance}", force: ${this.options.force}})&lt;/script>`;
          data.html = insertStringAfter(data.html, '&lt;head>', str);
        }
        // 动态加载资源
        const {
          headTags,
          bodyTags
        } = data;
        data.html = HtmlWebpackMixinRobot.insertRobotFunc(data.html, headTags, 'head', this.options);
        data.html = HtmlWebpackMixinRobot.insertRobotFunc(data.html, bodyTags, 'body', this.options);
        return data;
      });
    });
  }
}

// import type { Configuration } from "webpack"
/**
 * read env config file.the rule like create-react-env
 */
const readDotenvFiles = (environment, id) => {
  const dotenvCore = resolveApp('.env');
  const dotenvFiles = [`${dotenvCore}.${environment}.local`, process.env.NODE_ENV !== 'test' &amp;&amp; `${dotenvCore}.local`, `${dotenvCore}.${environment}`, dotenvCore].filter(Boolean);
  const dotenvData = {
    raw: {}
  };
  dotenvFiles.forEach(dotenvFile => {
    if (fs.existsSync(dotenvFile)) {
      // const { parsed } = require("dotenv").parse({ path: dotenvFile })
      // fs.readFileSync(dotenvFile as string)
      const parsed = require('dotenv').parse(fs.readFileSync(dotenvFile));
      Object.assign(dotenvData.raw, parsed);
    }
  });
  if (id) {
    const mark = dotenvData.raw[`${id}_KEY`] || environment;
    delete dotenvData.raw[`${id}_KEY`];
    dotenvData[mark] = {};
    for (const [key, val] of Object.entries(dotenvData.raw)) {
      if (key.startsWith(id)) dotenvData[mark][key.slice(id.length + 1)] = val;
    }
    delete dotenvData.raw;
  }
  return dotenvData;
};
/**
 * read all env config file
 */
const readAllDotenvFiles = (environments, id = '') => {
  // const dotenvCore = resolveApp(".env")
  // const dotenvFiles = environments.flat()
  // const readDotenvFiles = (environment: string, id: string) => {
  //   const dotenvFiles = [
  //     `${dotenvCore}.${environment}.local`,
  //     process.env.NODE_ENV !== "test" &amp;&amp; `${dotenvCore}.local`,
  //     `${dotenvCore}.${environment}`,
  //     dotenvCore,
  //   ].filter(Boolean)
  //   let dotenvData: Record&lt;string, any> = { raw: {} }
  //   dotenvFiles.forEach((dotenvFile) => {
  //     if (fs.existsSync(dotenvFile as PathLike)) {
  //       const { parsed } = require("dotenv").config({ path: dotenvFile })
  //       Object.assign(dotenvData.raw, parsed)
  //     }
  //   })
  //   if (id) {
  //     let mark = dotenvData.raw[`${id}_KEY`] || environment
  //     delete dotenvData.raw[`${id}_KEY`]
  //     dotenvData[mark] = {}
  //     for (const [key, val] of Object.entries(dotenvData.raw)) {
  //       if (key.startsWith(id)) dotenvData[mark][key] = val
  //     }
  //   }
  //   return dotenvData
  // }
  const allDotenvData = {
    raw: {}
  };
  if (id) allDotenvData[id] = {};
  environments.forEach(environment => {
    const {
      raw,
      ...rest
    } = readDotenvFiles(environment, id);
    raw &amp;&amp; Object.assign(allDotenvData.raw, {
      [environment]: raw
    });
    id &amp;&amp; Object.assign(allDotenvData[id], rest);
  });
  if (JSON.stringify(allDotenvData.raw) === '{}') delete allDotenvData.raw;
  return JSON.parse(JSON.stringify(allDotenvData), function (key, val) {
    if (key.startsWith('__') &amp;&amp; key !== id) {
      this[key.replace(/^__[^_]+_/, '')] = val;
    } else {
      return val;
    }
  });
};
/*
 * serialize value
 * */
const stringifyVal = target => {
  return Object.keys(target).reduce((env, key) => {
    env[key] = JSON.stringify(target[key]);
    return env;
  }, {});
};
/**
 * override configure by combine a list of function that used for modifing
 * */
const override = (...plugins) => plugins.filter(f => f).reduce((pre, cur) => {
  return (webpackConfig, extra = {}) => {
    return cur(pre(webpackConfig, extra), extra);
  };
});

/**
 * @description sass-resources-loader的craco版本插件
 * @exports sass-resources-loader
 * @version 1.0.1
 * @see {@link https://github.com/shakacode/sass-resources-loader#readme}
 * @example &lt;caption>craco.config.js&lt;/caption>
 * const { sassResourcesLoader } = '@biulight/craco-config-extensions'
 *
 * module.exports = {
 *   plugins: [
 *     {
 *       plugin: sassResourcesLoader,
 *       options: {
 *         resources: 'example/a.scss'
 *       }
 *     }
 *   ]
 * }
 */
var sassResourcesLoader = {
  overrideWebpackConfig: ({
    webpackConfig,
    pluginOptions
  }) => {
    const {
      isFound
    } = getLoader(webpackConfig, loaderByName('sass-loader'));
    if (isFound) {
      addAfterLoader(webpackConfig, loaderByName('sass-loader'), {
        loader: 'sass-resources-loader',
        options: pluginOptions
      });
    }
    return webpackConfig;
  }
};

export { HtmlWebpackInjectHead, HtmlWebpackMixinRobot, addDefinitionsEnvValue, addHtmlWebpackPlugin, addInterpolateHtmlPlugin, addSplitChunksPlugin, modifyOutputConfig, override, readAllDotenvFiles, readDotenvFiles, sassResourcesLoader, stringifyVal, writeConfigForDebug };
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a> on Sun Jun 18 2023 18:12:08 GMT+0800 (中国标准时间) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
